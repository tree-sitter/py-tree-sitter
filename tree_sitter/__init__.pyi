import enum
from ctypes import CDLL
from typing import List, Optional, Union

from tree_sitter.binding import LookaheadIterator as LookaheadIterator
from tree_sitter.binding import \
    LookaheadNamesIterator as LookaheadNamesIterator
from tree_sitter.binding import Node as Node
from tree_sitter.binding import Parser as Parser
from tree_sitter.binding import Query as Query
from tree_sitter.binding import QueryCapture as QueryCapture
from tree_sitter.binding import Range as Range
from tree_sitter.binding import Tree as Tree
from tree_sitter.binding import TreeCursor as TreeCursor

class SymbolType(enum.IntEnum):
    REGULAR: int
    ANONYMOUS: int
    AUXILIARY: int

class Language:
    name: str
    lib: Optional[CDLL]
    language_id: int

    @staticmethod
    def build_library(output_path: str, repo_paths: List[str]) -> bool: ...
    def __init__(self, path_or_ptr: Union[str, int], name: str) -> None: ...
    @property
    def version(self) -> int: ...
    @property
    def node_kind_count(self) -> int: ...
    @property
    def parse_state_count(self) -> int: ...
    def node_kind_for_id(self, id: int) -> Optional[str]: ...
    def id_for_node_kind(self, kind: str, named: bool) -> Optional[int]: ...
    def node_kind_is_named(self, id: int) -> bool: ...
    def node_kind_is_visible(self, id: int) -> bool: ...
    @property
    def field_count(self) -> int: ...
    def field_name_for_id(self, field_id: int) -> Optional[str]: ...
    def field_id_for_name(self, name: str) -> Optional[int]: ...
    def next_state(self, state: int, id: int) -> int: ...
    def lookahead_iterator(self, state: int) -> Optional[LookaheadIterator]: ...
    def query(self, source: str) -> Query: ...
